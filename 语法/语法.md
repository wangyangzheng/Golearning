# Golearning

#### 学习路径

由郝林哥整理
![lPAVZ.jpg](https://s1.328888.xyz/2022/05/26/lPAVZ.jpg)


#### 第一个程序
1. Go语言的main函数没有返回值，但是可以使用`os.Exit(0)`进行退出

#### 变量和数据类型

1. Go语言不支持变量的隐式类型的转化,但是支持显示的类型转换
2. Go语言支持数据类型的推导
3. Go语言的bool类型只有两个值分别是`true`和`false`
4. Go语言的常量可以自动赋值
5. Go语言的指针类型不可以直接进行加加减减
6. string类型默认是空字符串


#### 运算符
1. Go语言将前缀的++和--删除了
2. Go语言支持`&^`这个符号的含义是先将右边的数字进行取反，然后在与左边的数进行`&`运算


#### 循环语句和循环语句
1. Go语言中支持一边赋值,一边判断条件的条件语句
2. Go语言只支持`for`循环
3. Go语言的`switch`不需要使用`break`这个关键字

```go
func TestArray1(t *testing.T) {
	arr := [...]int {1, 2, 3}
	if ok := arr[0] == 1; ok{
		t.Log(arr[0])
	}
}
```

```go
func TestArray(t *testing.T) {
	arr := [...] int {1, 2, 3, 5}
	//idx表示下标,value表示值
	for idx, value := range arr {
		t.Log(idx, value)
	} 
}
```

#### 数组
1. 数组的声明
```go
var a int [3]
arr := [3] int {1, 2, 3}
//二维数组
arr := [2][2] int {{1, 2}, {3, 4}}
```
2. 数组是可以进行截取的
```golang
a[1, 2]
```
3. 数组的长度
可以使用`len()`函数
#### 切片
1. 切片有长度，个数， 容量
2. 切片的内存是共享的
```go
//这是切片
func TestSlice(t *testing.T) {
	var s0 []int
	//len()是数组的长度,cap表示数组的容量
	t.Log(len(s0), cap(s0))

	//填入一个元素
	s0 = append(s0, 1)

	s1 := []int{1, 2, 3, 4}
	t.Log(len(s1), cap(s1))

	//表示长度是3,容量是5
	s2 := make([]int, 3, 5)
	t.Log(len(s2), cap(s2))
	t.Log(s2[0], s2[1], s2[2])

	//这样会发生越界t.Log(s2[0], s2[1], s2[2], s3[3])
	s2 = append(s2, 1)
	t.Log(s2[3])
}

func TestSliceGrowing(t *testing.T) {
	s := []int{}
	for i := 0; i < 10; i++ {
		//结构体的内存进行扩展
		s = append(s, i)
		t.Log(len(s), cap(s))
	}
}

func TestSliceShareMemory(t *testing.T) {
	year := []string{"jan", "feb", "mar", "apr", "may", "jun", "jul", " aug", "sep", "Qct", "Nov", "Dec"}
	Q2 := year[3:6]
	t.Log(Q2, len(Q2), cap(Q2))
	summer := year[5:8]
	t.Log(summer, len(summer), cap(summer))
	//看看这两个数组的地址
	summer[0] = "Unknow"
	t.Log(Q2)
}
```
#### map
1. map有两部分组成一部分是`键`,一部分是`值`
2. map的三种声明方式
```go
m1 := map[int]int{1 : 1, 2 : 2}
m2 := map[int]int {}
//这里的10指的是容量
m3 := make(map[int] int, 10)
```
3. 如果map种不存在某个键,那么系统自动为它的值赋上0

#### 字符串
1. 字符串的切片不可以改变
2. 字符串的编码是unicode,编码规则是utf-8
3. 字符串的相关操作

#### 函数
1. 函数可以有多个返回值
2. 函数的返回值可以是函数
3. 函数的参数是可变长的
4. Go语言中还有延时函数


关于函数可以有多个返回值的演示
```go
func returnMultiValues() (int, int) {
	return rand.Intn(10), rand.Intn(20)	
}

func TestFn(t *testing.T) {
	a, b := returnMultiValues()
	t.Log(a, b) 
	
}
```

函数的返回值也可以是函数
```go
func timeFn(inner func (op int) int) func (op int) int {
	return func (n int) int {
		start := time.Now()
		ret := inner(n)
		fmt.Println("time spent:", time.Since(start).Seconds())
		return ret
	}
}

//传入的参数
func slowFun(op int) int {
	time.Sleep(time.Second * 1)
	return op 
}

func TestFn1(t *testing.T) {
	tsSF := timeFn(slowFun)
	t.Log(tsSF(10))
}

```


关于可变长参数的演示
```go
//opd是可变长参数
func Sum(ops ...int) int {
	res := 0
	for _, op := range ops {
		res += op
	}
	return res
}

func TestVarParam(t *testing.T) {
	t.Log(Sum(1, 2, 3, 4))
	t.Log(Sum(1, 2, 3, 4, 5))
}
```
关于defer的使用
可以帮助我们释放锁
```
func TestDefer(t *testing.T) {
	defer Clear()
	fmt.Println("start")
	//报错,退出
	panic("err")
	//不会执行
	fmt.Print("err")
}
```
##### 面向对象
首先Go语言是否支持面向对象
>既可以说GO语言支持面向对象，也可以说Go语言不支持面向对象

结构体的定义
```go
    type Employee struct {
        Id string
        Name string
        Age int
    }
```
实例创建及初始化
```go
    e := Employee {"0", "Bob", 20}
    e1 := Employee {Name : "Tom", Age : 30}
    e2 := new(Employee)
    e2.Id = "2"
    e2.Age = 22
    e2.Name = "Rose"
```
e2 := new(Employee)相当于`e2 := &Employee{}`但是调用的时候不需要箭头

```go
package opp_test

import "testing"

func TestCreatEmployeeObj(t *testing.T) {
	type Employee struct {
        Id string
        Name string
        Age int
    }
	e := Employee {"0", "Bob", 20}
    e1 := Employee {Name : "Tom", Age : 30}
    e2 := new(Employee)
    e2.Id = "2"
    e2.Age = 22
    e2.Name = "Rose"
	t.Log(e)
	t.Log(e1)
	//输出类型e2的类型
	t.Logf("%T", e2)
}
```
方法的定义

```go
func (e Employee) String() string {
    return fmt.Sprintf("ID: %S-Name:%s-Age:%d", e.Id, e.Name, e.Age)
}
```
这种定义方式在实例对应方法被调用时候实例的成员会进行值的复制
为了避免程序内存的拷贝我们使用下面这种方法
```go
func (e *Employee) String() string {
    return fmt.Sprintf("ID: %S-Name:%s-Age:%d", e.Id, e.Name, e.Age)
}
```
```go
func (e *Employee) String() string {
	fmt.Printf("Adress is %x\n", unsafe.Pointer(&e.Name))
    return fmt.Sprintf("ID: %S-Name:%s-Age:%d", e.Id, e.Name, e.Age)
}
```
```go
String()//调用
fmt.Printf("Adress is %x\n", unsafe.Pointer(&e.Name))
```
发现两者的地址是相同的，但是使用第一种方法是两者的地址不一样的
